"""
Spiral Exponential Function Visualizer
--------------------------------------
This script provides an interactive visualization of trajectories generated by
the Spiral Exponential Function, which arises as a solution of the Spiral
Exponential Equation (SEE).

Concept (what this is showing)
------------------------------
We consider a motion in the complex plane whose position at time t is represented
by a complex-valued function f(t). In the framework of the Spiral Exponential
Equation, the central geometric parameter is the angle θ between the position
vector and the velocity vector.

- The position vector is the complex value f(t) itself, pointing from the origin
  to the point f(t) in the complex plane.
- The velocity direction is defined by a rotation of the position vector by an
  angle θ:
        f'(t) = e^{iθ} f(t)
- The acceleration direction is obtained by a further rotation, giving:
        f''(t) = e^{i2θ} f(t)

Thus, each successive derivative corresponds geometrically to a rotation of the
original position vector by an additional angle θ.

A representative solution that exhibits this “rotation-by-θ per derivative”
structure is given by
        f(t) = exp( exp(iθ) · t ).

By varying θ continuously, the relative orientation between the position and
velocity vectors changes. As a result, the orbit transitions smoothly between
growth-dominated behavior (θ near 0) and rotation-dominated behavior (θ near
π/2). This script visualizes this continuous family of motions directly in the
complex plane.

Note on vector overlays
-----------------------
The position, velocity, and higher-order vectors drawn at the current point are
shown according to the geometric structure prescribed by the Spiral Exponential
Equation. Specifically, the k-th order direction is proportional to
        e^{ikθ} f(t),
making the θ, 2θ, 3θ, and 4θ rotational structure of successive derivatives
explicit in the visualization.

What you can do with this app
-----------------------------
- Adjust θ (theta) using a slider to control the angle between the position and
  velocity directions.
- Adjust t (time) using a slider to move along the trajectory from t = 0 to the
  current time.
- Observe the trajectory f(t) traced in the complex plane up to the current time.
- Display the current position f(t) as a marker.
- Toggle vector overlays:
    * Show vectors: display position, velocity, and acceleration directions.
    * Show jerk:    optionally display the third-derivative direction (3θ).
    * Show snap:    optionally display the fourth-derivative direction (4θ).
- Examine how higher-order derivative directions are arranged by integer
  multiples of θ at the current position.

Notes
-----
- Colors are fixed for clarity:
    * Position vector      = green
    * Velocity vector      = blue
    * Acceleration vector  = red
    * Jerk vector          = purple (optional)
    * Snap vector          = orange (optional)
- The legend is placed outside the plot area to keep the trajectory unobstructed.
"""
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, CheckButtons

# Spiral exponential function:
# f(t) = exp(exp(iθ) t)
def spiral_exp(t, theta):
    return np.exp(np.exp(1j * theta) * t)

# Update function for all interactive controls
def update(val):
    theta = s_theta.val
    t = s_t.val

    # Time samples from 0 to t
    t_vals = np.linspace(0.0, max(t, 1e-6), 400)
    f_vals = spiral_exp(t_vals, theta)

    # Current position as a complex number
    pos = spiral_exp(t, theta)

    # Vectors based on the Spiral Exponential Equation (SEE)
    vel  = np.exp(1j * theta)      * pos   # velocity
    acc  = np.exp(1j * 2 * theta)  * pos   # acceleration
    jerk = np.exp(1j * 3 * theta)  * pos   # jerk
    snap = np.exp(1j * 4 * theta)  * pos   # snap

    # Read checkbox states
    vectors_on, jerk_on, snap_on = check.get_status()

    # Determine effective visibility
    # (jerk/snap are ignored if vectors are OFF)
    jerk_effective = vectors_on and jerk_on
    snap_effective = vectors_on and snap_on

    # Visual feedback for disabled checkboxes
    for i, text in enumerate(check.labels):
        if i == 0:  # "Show vectors"
            text.set_color("black")
        else:       # "Show jerk", "Show snap"
            text.set_color("black" if vectors_on else "0.5")

    ax.clear()

    # Trajectory of f(t) in the complex plane
    ax.plot(f_vals.real, f_vals.imag, label="Trajectory f(t)")

    # Current position marker
    ax.scatter([pos.real], [pos.imag],
               s=60, color="black", label="Current position")

    if vectors_on:
        # Position vector (origin → pos) [GREEN]
        ax.arrow(
            0, 0, pos.real, pos.imag,
            length_includes_head=True,
            head_width=0.08, head_length=0.15,
            color="green", alpha=0.7,
            label="Position vector"
        )

        # Velocity vector (pos → pos + vel) [BLUE]
        ax.arrow(
            pos.real, pos.imag, vel.real, vel.imag,
            length_includes_head=True,
            head_width=0.08, head_length=0.15,
            color="blue", alpha=0.7,
            label="Velocity vector"
        )

        # Acceleration vector (pos → pos + acc) [RED]
        ax.arrow(
            pos.real, pos.imag, acc.real, acc.imag,
            length_includes_head=True,
            head_width=0.08, head_length=0.15,
            color="red", alpha=0.7,
            label="Acceleration vector"
        )

        # Jerk vector (optional) [PURPLE]
        if jerk_effective:
            ax.arrow(
                pos.real, pos.imag, jerk.real, jerk.imag,
                length_includes_head=True,
                head_width=0.08, head_length=0.15,
                color="purple", alpha=0.7,
                label="Jerk vector"
            )

        # Snap vector (optional) [ORANGE]
        if snap_effective:
            ax.arrow(
                pos.real, pos.imag, snap.real, snap.imag,
                length_includes_head=True,
                head_width=0.08, head_length=0.15,
                color="orange", alpha=0.7,
                label="Snap vector"
            )

    # Set axis limits based on trajectory size
    r = np.max(np.abs(f_vals)) * 1.2
    if r < 2.0:
        r = 2.0
    ax.set_xlim(-r, r)
    ax.set_ylim(-r, r)

    # Axis styling
    ax.set_aspect("equal", "box")
    ax.grid(True)
    ax.set_xlabel("Re")
    ax.set_ylabel("Im")
    ax.set_title(
        fr"$f(t)=\exp(e^{{i\theta}} t),\ \theta={theta:.2f},\ t={t:.2f}$"
    )

    # Legend outside the plot (right side)
    handles, labels = ax.get_legend_handles_labels()
    unique = dict(zip(labels, handles))
    ax.legend(
        unique.values(), unique.keys(),
        loc="center left",
        bbox_to_anchor=(1.02, 0.8),
        borderaxespad=0.,
    )

    fig.canvas.draw_idle()


# ---------- Main setup ----------

fig, ax = plt.subplots(figsize=(7, 6))

# Set application (window) title
fig.canvas.manager.set_window_title(
    "Trajectory Generated by the Spiral Exponential Function"
)

# Leave space for sliders and checkboxes
plt.subplots_adjust(left=0.1, right=0.75, bottom=0.25)

# Axes for sliders (θ and t)
ax_theta = plt.axes([0.15, 0.12, 0.7, 0.03])
ax_t     = plt.axes([0.15, 0.06, 0.7, 0.03])

# Axes for checkboxes (vector visibility)
ax_checks = plt.axes([0.78, 0.4, 0.18, 0.15])

# Sliders for θ and t
s_theta = Slider(ax_theta, "θ", 0.0, 2 * np.pi,
                 valinit=np.pi / 4, valstep=0.01)
s_t     = Slider(ax_t, "t", 0.0, 10.0,
                 valinit=1.0,       valstep=0.01)

# Checkboxes:
# 0: Show vectors (position, velocity, acceleration)
# 1: Show jerk
# 2: Show snap
check = CheckButtons(
    ax_checks,
    labels=["Show vectors", "Show jerk", "Show snap"],
    actives=[True, False, False]
)

# Connect widgets to update function
s_theta.on_changed(update)
s_t.on_changed(update)
check.on_clicked(update)

# Initial draw
update(None)

plt.show()
